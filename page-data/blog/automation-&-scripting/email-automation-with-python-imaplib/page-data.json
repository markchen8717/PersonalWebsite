{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/automation-&-scripting/email-automation-with-python-imaplib","result":{"data":{"contentfulBlogPost":{"postContent":{"json":{"nodeType":"document","data":{},"content":[{"nodeType":"paragraph","content":[{"nodeType":"text","value":"A paperless business could be a safer business in an ongoing pandemic. There are many modifications that a business could apply to its document management system to reduce paper. For example, businesses may consider digitizing documents and exchanging them through email with their clients instead mailing physical copies. With any digital data, it is extremely important to make multiple backups, both online and offline. Leaving all the documents inside the email is not the way to go.","marks":[],"data":{}}],"data":{}},{"nodeType":"heading-1","content":[{"nodeType":"text","value":"","marks":[],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"Recently, I was tasked with automating the email download process for a client. The client wished to periodically run a Python script on their Windows server, which it will download new emails from a particular mailbox into a specified directory for further processing. This standalone script was just a small role of the complex document management system the client operates. I will go through with you the big picture of the script and highlight the important areas, so without further ado, let's dive right in!","marks":[],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"","marks":[],"data":{}},{"nodeType":"hyperlink","content":[{"nodeType":"text","value":"<code python>","marks":[],"data":{}}],"data":{"uri":" "}},{"nodeType":"text","value":"","marks":[{"type":"code"}],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"import imaplib\nimport getpass\nimport email\nimport re","marks":[{"type":"code"}],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"","marks":[{"type":"code"}],"data":{}},{"nodeType":"hyperlink","content":[{"nodeType":"text","value":"</code>","marks":[],"data":{}}],"data":{"uri":" "}},{"nodeType":"text","value":"","marks":[],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"These are the python modules we need for the script. Both ","marks":[],"data":{}},{"nodeType":"text","value":"imaplib","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" and ","marks":[],"data":{}},{"nodeType":"text","value":"email ","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":"will be used to navigate the mailbox and process the emails inside. More details on ","marks":[],"data":{}},{"nodeType":"text","value":"getpass ","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":"and ","marks":[],"data":{}},{"nodeType":"text","value":"re","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" later.","marks":[],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"","marks":[],"data":{}},{"nodeType":"hyperlink","content":[{"nodeType":"text","value":"<code python>","marks":[],"data":{}}],"data":{"uri":" "}},{"nodeType":"text","value":"","marks":[{"type":"code"}],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"IMAP_SERVER = 'imap-mail.outlook.com'  # change this accordingly to mailbox type\n# change this to a string literal of the email address\nEMAIL_ACCOUNT = input('Email address:')\nEMAIL_FOLDER = \"Sent\"\nOUTPUT_DIRECTORY = './'  # root directory of this script","marks":[{"type":"code"}],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"# you may change this to a string literal of the email password\nPASSWORD = getpass.getpass('Email password:')","marks":[{"type":"code"}],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"","marks":[{"type":"code"}],"data":{}},{"nodeType":"hyperlink","content":[{"nodeType":"text","value":"</code>","marks":[],"data":{}}],"data":{"uri":" "}},{"nodeType":"text","value":"","marks":[],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"These are the variables to hold the email account credentials and configurations. ","marks":[],"data":{}},{"nodeType":"text","value":"getpass","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" is used to mask user input from the terminal for security purposes. If you choose to overwrite the line with a string literal of your password, remember to make sure that the read permissions of the script is set appropriately to prevent leaking your password.","marks":[],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"","marks":[],"data":{}},{"nodeType":"hyperlink","content":[{"nodeType":"text","value":"<code python>","marks":[],"data":{}}],"data":{"uri":" "}},{"nodeType":"text","value":"","marks":[],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"def get_last_msg_uid():\n    rv = None\n    with open('last_msg_uid.dat', 'rb') as f:\n        rv = f.read()\n    return rv","marks":[{"type":"code"}],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"\ndef set_last_msg_uid(uid):\n    with open('last_msg_uid.dat', 'wb') as f:\n        f.write(uid)","marks":[{"type":"code"}],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"","marks":[{"type":"code"}],"data":{}},{"nodeType":"hyperlink","content":[{"nodeType":"text","value":"</code>","marks":[],"data":{}}],"data":{"uri":" "}},{"nodeType":"text","value":"","marks":[],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"Included inside the root directory of the script is a file named ","marks":[],"data":{}},{"nodeType":"text","value":"last_msg_uid.dat","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":",","marks":[],"data":{}},{"nodeType":"text","value":" ","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":"which holds an integer, the unique ID to the last downloaded email that the mailbox has assigned. Each time the script is ran, it retrieves for the ID to the last downloaded email and updates it using the ","marks":[],"data":{}},{"nodeType":"text","value":"get_last_msg_uid() ","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":"and ","marks":[],"data":{}},{"nodeType":"text","value":"set_last_msg_uid() ","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":"functions respectively. It is important to notice that the ID is read and written in bytes, more details on this later.","marks":[],"data":{}}],"data":{}},{"nodeType":"heading-1","content":[{"nodeType":"text","value":"","marks":[],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"This next function will be doing majority of the work, hence, it is lengthy, but I will explain it in smaller pieces for a better understanding.","marks":[],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"","marks":[],"data":{}},{"nodeType":"hyperlink","content":[{"nodeType":"text","value":"<code python>","marks":[],"data":{}}],"data":{"uri":" "}},{"nodeType":"text","value":"","marks":[],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"def process_mailbox(M):\n    print(\"Checking for new messages\")\n    last_msg_uid = get_last_msg_uid()\n    if not last_msg_uid:\n        print(\"ERROR getting last message UID\")\n        return\n    last_msg_uid = int(last_msg_uid)","marks":[{"type":"code"}],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"","marks":[{"type":"code"}],"data":{}},{"nodeType":"hyperlink","content":[{"nodeType":"text","value":"</code>","marks":[],"data":{}}],"data":{"uri":" "}},{"nodeType":"text","value":"","marks":[],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"We will first acquire the ID of the last downloaded email using the previously introduced functions. Notice that we've cast the ","marks":[],"data":{}},{"nodeType":"text","value":"last_msg_uid","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" from bytes to an integer. ","marks":[],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"","marks":[],"data":{}},{"nodeType":"hyperlink","content":[{"nodeType":"text","value":"<code python>","marks":[],"data":{}}],"data":{"uri":" "}},{"nodeType":"text","value":"","marks":[],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"# fetch for only emails that are newer than last fetched email\n    rv, message_ids = M.search(None, \"UID %d:*\" % (last_msg_uid + 1))\n    if rv != 'OK':\n        print(\"No new messages found\")\n        return","marks":[{"type":"code"}],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"","marks":[],"data":{}},{"nodeType":"hyperlink","content":[{"nodeType":"text","value":"</code>","marks":[],"data":{}}],"data":{"uri":" "}},{"nodeType":"text","value":"","marks":[],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"This function takes an ","marks":[],"data":{}},{"nodeType":"text","value":"impalib","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" mailbox object as argument, ","marks":[],"data":{}},{"nodeType":"text","value":"M","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":". Our goal is to query for the new and yet to be downloaded emails from the mailbox. We do this by making a search request to the mailbox object for email IDs that are greater than the ","marks":[],"data":{}},{"nodeType":"text","value":"last_msg_uid","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":". By now, you probably have realized that in order for this work, newly arrived emails must be assigned with an unique integer ID that is greater than the IDs of the older emails. This is indeed how the mailbox object organizes its emails.","marks":[],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"","marks":[],"data":{}},{"nodeType":"hyperlink","content":[{"nodeType":"text","value":"<code python>","marks":[],"data":{}}],"data":{"uri":" "}},{"nodeType":"text","value":"","marks":[],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"    for num in message_ids[0].split():\n        if int(num) <= last_msg_uid:\n            continue  # discard emails that already fetched\n        rv, data = M.fetch(num, '(RFC822)')\n        if rv != 'OK':\n            print(\"ERROR getting message\", int(num))\n            return","marks":[{"type":"code"}],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"","marks":[{"type":"code"}],"data":{}},{"nodeType":"hyperlink","content":[{"nodeType":"text","value":"</code>","marks":[],"data":{}}],"data":{"uri":" "}},{"nodeType":"text","value":"","marks":[],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"For each message ID that is returned from the previous search request, we double check if it is indeed greater than the ","marks":[],"data":{}},{"nodeType":"text","value":"last_msg_uid","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":",","marks":[],"data":{}},{"nodeType":"text","value":" ","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":"prior to making a fetch request to the mailbox object for the actual email. This may seem redundant, but from my experience, the mailbox object sometimes returns IDs that are less than the ","marks":[],"data":{}},{"nodeType":"text","value":"last_msg_uid","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":", despite the explicit request string. I have not yet had the pleasure to know why, and would greatly appreciate anyone who wants to shed some light on this. Once more, the variable type of the message ID produced by the mailbox object is bytes, not integer, hence, we must cast it to an integer before comparing it with the ","marks":[],"data":{}},{"nodeType":"text","value":"last_msg_uid","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":".","marks":[],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"","marks":[],"data":{}},{"nodeType":"hyperlink","content":[{"nodeType":"text","value":"<code python>","marks":[],"data":{}}],"data":{"uri":" "}},{"nodeType":"text","value":"","marks":[],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"# acquire the subject of the email\n        email_subject = email.message_from_string(\n            data[0][1].decode('utf-8'))['Subject']\n        email_subject_cleaned = re.sub('[^\\w\\-_\\. ]', '_', email_subject)\n        print(\"Downloading message\", int(num))\n        if not data is None:\n            with open('%s/%d-%s.eml' % (OUTPUT_DIRECTORY, int(num), email_subject_cleaned), 'wb') as f:\n                f.write(data[0][1])\n            set_last_msg_uid(num)\n    print(\"Done downloading new messages\")","marks":[{"type":"code"}],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"","marks":[],"data":{}},{"nodeType":"hyperlink","content":[{"nodeType":"text","value":"</code>","marks":[],"data":{}}],"data":{"uri":" "}},{"nodeType":"text","value":"","marks":[],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"The client requested for emails to be downloaded as ","marks":[],"data":{}},{"nodeType":"text","value":".eml ","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":"files with the naming convention of its ID followed by the email subject. We can obtain the ","marks":[],"data":{}},{"nodeType":"text","value":"email_subject","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" with the help of Python's ","marks":[],"data":{}},{"nodeType":"text","value":"email","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" module. Essentially, we decode the email from bytes to ","marks":[],"data":{}},{"nodeType":"text","value":"utf-8","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" and give that as argument to the ","marks":[],"data":{}},{"nodeType":"text","value":"message_from_string()","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" function, which will return a dictionary with ","marks":[],"data":{}},{"nodeType":"text","value":"Subject ","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":"as one of its keys. It is important to lookout for potential illegal characters (varies for operating systems) for any naming convention. In this case, we had to clean the ","marks":[],"data":{}},{"nodeType":"text","value":"email_subject","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" with regex to avoid file naming errors on Windows. The email is downloaded as bytes with the ","marks":[],"data":{}},{"nodeType":"text","value":".eml ","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":"extension, in which all of its attachments will be included inside.","marks":[],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"","marks":[],"data":{}},{"nodeType":"hyperlink","content":[{"nodeType":"text","value":"<code python>","marks":[],"data":{}}],"data":{"uri":" "}},{"nodeType":"text","value":"","marks":[],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"def main():\n    M = imaplib.IMAP4_SSL(IMAP_SERVER)\n    M.login(EMAIL_ACCOUNT, PASSWORD)\n    rv, data = M.select(EMAIL_FOLDER)\n    if rv == 'OK':\n        process_mailbox(M)\n        M.close()\n    else:\n        print(\"ERROR: Unable to open mailbox \"), rv\n    M.logout()","marks":[{"type":"code"}],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"\nif __name__ == \"__main__\":\n    main()","marks":[{"type":"code"}],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"","marks":[],"data":{}},{"nodeType":"hyperlink","content":[{"nodeType":"text","value":"</code>","marks":[],"data":{}}],"data":{"uri":" "}},{"nodeType":"text","value":"","marks":[],"data":{}}],"data":{}},{"nodeType":"paragraph","content":[{"nodeType":"text","value":"Last but not least, this is the ","marks":[],"data":{}},{"nodeType":"text","value":"main() ","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":"function where we create our mailbox object, ","marks":[],"data":{}},{"nodeType":"text","value":"M","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":", using the ","marks":[],"data":{}},{"nodeType":"text","value":"imaplib ","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":"module. We then initialize it, by logging in with our credentials, along with navigating to the inbox of interest. After that, we call the ","marks":[],"data":{}},{"nodeType":"text","value":"process_mailbox() ","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":"function introduced earlier, with ","marks":[],"data":{}},{"nodeType":"text","value":"M","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" as an argument.","marks":[],"data":{}}],"data":{}}]}}}},"pageContext":{"postTitle":"Email Automation with Python imaplib","postDescription":"One step closer to a paperless office. Two steps up on organization and management."}}}